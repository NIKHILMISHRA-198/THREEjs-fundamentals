There are 4 Properties to transform Objects

*position
*scale
*rotation
*quaternion


To move objects,
Position.
*x
*y
*z


Object3D instances have lookAt(...) method which rotates the object so that its -z faces the target you provided
The target must be a Vector3

camera.lookAt(new THREE.Vector3(0,-1,0))



You can put objects inside groups and use position, rotation (or quaternion),  and scale on those groups
To do that, use the Group class\\\

_____________________________________________________________________________________________
//Animations//


The purpose of requestAnimationFrame is to call the function provided on the next requestAnimationFrame
We are going to call the same function on each new frame

create tick function and call its
In the function calll it again but using window.requestAnimationFrame(...)


const tick =() => {
    console.log('tick')
    window.requestAnimationFrame(tick)
}

tick()

We need to know how much time it's been since the last tick
Use Date.now()  to get the timestamp

const time  = Date.now()


instead of using time = Date.now()

another solution to it is a built in function in THREE.js i.e Clock

Instantiate a Clock and use its getElapsedTime() method
const clock = new THREE.clock()

const tick=  () => {
    const elapsedTime  = clock.getElapsedTime()

    //update Objects
    mesh.rotation.y = elapsedTime
    //
}


If you want to have more control, create tweens,  create timelines etc. use GSAP like libraries.

//using GSAP

gsap.to(mesh.position, {duration: 1, x: 2})

const tick=  () => {
    //Render

    renderer.render(scene, camera)

    //call tick again on the next frame
    window.requestAnimationFrame(tick)
}
tick()

_____________________________________________________________________________________________
//Camera is an abstract class, You are not supposed to use it directly

//ArrayCamera render the scene from multiple cameras on specific areas of the render

//StereoCamera render the scene through two camera that mimic the eyes to create a parallax effect
Use with device like VR headset, red and blue glasses or cardboard

//Cubecamera do 6 renders, each one facing a different direction 
can render the surrounding for things like environment map, reflection or shadow map

//OrthographicCamera render the scene without perspective

//PerspectiveCamera the scenewith perspective

We will be using OrthographicCamera and PerspectiveCamera


_____________________________________________________________________________________________
THREE.PerspectiveCamera( 45, width / height, 1, 1000 );


Field Of view"
*Vertical vision angle
*In degrees
*also called fov


Aspect ratio:   (Width of the render)/ (height of the render)

near and frame:  how close/far the camera can see.

_____________________________________________________________________________________________

THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );

THREE.OrthographicCamera(left, right, top, bottom, near, far)

//Cursor assignment

const cursor =
{
    x: 0,
    y: 0
}

window.addEventListener('mousemove', (event) => {
    cursor.x = event.clientX / sizes.width - 0.5
    cursor.y = event.clientY / sizes.height
})

_____________________________________________________________________________________________

Move the camera around the center of the scene by using Math.sin(...),Math.cos(...) and Math.Position

_____________________________________________________________________________________________


//Controls

1. DeviceOrientationControls
2. FlyControls
3. FirstPersonControl
4. OrbitControls
5. PointerLockControl
6. TrackballControls
7. TransformControls
8. DragControls

//The damping will smooth the animation by adding some kind of acceleration and friction

To enable damping, switch the enableDamping property to true

const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true
 remember to add controls.add inside tick() function!!
_____________________________________________________________________________________________

